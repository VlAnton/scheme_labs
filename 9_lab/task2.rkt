#lang racket

(define (task2 n)
  (define row_of_ones (build-list n (lambda(x) 1)))  ; список единичек создаём отдельно, потому что для нечётных он не генерится

  (define matrix (foldl (λ(idx matr)  ; генерируем матрицу. Аргументы:
                                                                ; matr – матрица
                                                                ; idx – текущий "индекс". На самом деле, он на каждом шаге означает количество единичек в половинке строки матрицы
                          ; Используем foldl, потому что foldr и map добавляют элементы справа (видимо), поэтому получается не нужная фигура, а ромбик из ноликов
                          (define row (build-list n (lambda (i)  ; генерируем строку с помощью build-list. i - просто числа от 0 до n
                                                      (if (< i idx)  ; 
                                                          1  ; если i < idx, то возвращаем 1
                                                          (if (<= (- n i) idx)  ; иначе мы проверяем то же самое, но как бы с индексом от конца строки
                                                                                ; чтобы единички генерились симметрично (:
                                                              1
                                                              0
                                                              )
                                                          )
                                                      )
                                                  )
                            )
                          (cons row matr)  ; в конце просто добавляем строку к матрице
                          ) '() (build-list (quotient n 2) (λ(x) (+ 1 x)))  ; список "индексов" будет длины n // 2 (об этом ниже)
                                                                            ; такая функция λ, потмоу что в оригинале все эти x – числа от 0 до n, а нужно от 1 до n+1
                                                                            ; (можешь написать values вместо этой функции и посмотреть что будет)
                            )
    )
  (if (even? n)  ; у нас сгенерирована половина матрицы. Но n может быть как чётным, так и нечётным, поэтому на этой строке просто проверяем
      (append (reverse matrix) matrix)  ; если строка чётная, то добавляем к существующей половине матрицы отзеркаленную с помощью reverse матрицу функцией append
      (append (reverse matrix) (cons row_of_ones matrix))  ; иначе делаем по сути тоже самое, но предварительно добавим к существующей половине матрицы строку из единичек, потому что в коде она не сгенерится
      )
  )
