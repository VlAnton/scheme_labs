#lang racket

(define (split str)  ; это как split из 3 задачки, но разделитель всегда пробел и вычисляется проще
  (define space #\space)  ; просто для красоты вынес символ пробела в константу )

  (foldr (λ(char result)
           (define current_word (car result))  ; беру текущее слово
           (define str_char (string char))  ; строковое представление символа
           (define next_word (string-append str_char current_word))  ; новое слово (старое + текущий символ)

           (if (equal? char space)  ; проверяем что текущий символ пробел
               (cons "" result)  ; если символ пробел, добавляем новое пустое слово к результату (это чтобы накапливать новое потенциальное слово)
               (cons next_word (cdr result))  ; если символ не пробел, то заменяем текущее слово на новое
               )
           )
         '("")  ; результат — список слов
         (string->list str)  ; переводим строку в список символов
         )
  )



(define (find-dupes str)
  (define list-of-words (split str))  ; делим строку на слова
  (define idxs (range (length list-of-words)))  ; список индексов

  (foldl (λ(idx word result)
           (define dupe  ; это результат для текущего слова. Алгоритм в том, что мы проходимся для каждого слова по списку слов из строки и сравниваем их
             (foldl (λ(inner_idx inner_word inner_result)  ; inner_idx — индекс для слова во внутреннем foldl, inner_word — то самое слово, а inner_result — результат работы внутреннего foldl
                      (cond
                        [(non-empty-string? result) result]  ; если ответ внешнего foldl (result) является непустой строкой => мы нашли повторение и на этой строчке все последующие
                        ; итерации будут просто возвращать полученное значение. Это чтобы внешний результат не потерять, потому что мы ищем внутренний ещё (inner_result)
                        [(non-empty-string? inner_result) inner_result]  ; аналогичное условие для inner_result. Если нашли слово, останавливаем поиск и на каждой итерации возвращаем его
                        ; Потом отдадим его в result и будем всегда возвращать result
                        [(and (not(equal? idx inner_idx)) (equal? inner_word word)) inner_word]  ; тут мы проверяем что слово можно поместить в результат.
                        ; word должно равняться текущему inner_word, но их индексы не должны быть равны. Например, есть список слов '("1" "3" "3")
                        ; на первом этапе мы будем искать слово, равное "1". И на первой же итерации получим inner_word = "1" и word = "1". Они как бы равны, но они на одной
                        ; позиции в списке, а значит это в принципе одно и то же слово. Не круто, поэтому надо проверять индексы
                        [else #f]  ; иначе, слова не равны и в результате будет #f )
                        )
                      )
                    ""
                    idxs
                    list-of-words
                    )
             )
           (cond  ; это уже происходит во внешнем foldl
             [(non-empty-string? result) result]  ; Если в result уже есть непустая строка, то возвращаем её.
             [else dupe]  ; иначе, берём результат из dupe
             )
           )
         ""
         idxs
         list-of-words
         )
  )